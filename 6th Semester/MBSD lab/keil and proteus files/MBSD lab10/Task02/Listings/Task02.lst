C51 COMPILER V9.60.0.0   TASK02                                                            08/02/2022 17:06:53 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE TASK02
OBJECT MODULE PLACED IN .\Objects\Task02.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Task02.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\Ta
                    -sk02.lst) TABS(2) OBJECT(.\Objects\Task02.obj)

line level    source

   1          /* Main.c file generated by New Project wizard
   2           *
   3           * Created:   Tue Jun 14 2022
   4           * Processor: AT89C51
   5           * Compiler:  Keil for 8051
   6           */
   7          
   8          
   9          #include <reg51.h>
  10          #include <stdio.h>
  11          //Function declarations
  12          void cct_init(void);
  13          void delay(int);
  14          void lcdinit(void);
  15          void writecmd(int);
  16          void writedata(char);
  17          void Return(void);
  18          char READ_SWITCHES(void);
  19          char get_key(void);
  20          //*******************
  21          //Pin description
  22          /*
  23          P2 is data bus
  24          P3.7 is RS
  25          P3.6 is E
  26          P1.0 to P1.3 are keypad row outputs
  27          P1.4 to P1.6 are keypad column inputs
  28          */
  29          //********************
  30          // Define Pins
  31          //********************
  32          sbit RowA = P1^0; //RowA
  33          sbit RowB = P1^1; //RowB
  34          sbit RowC = P1^2; //RowC
  35          sbit RowD = P1^3; //RowD
  36          sbit C1 = P1^4; //Column1
  37          sbit C2 = P1^5; //Column2
  38          sbit C3 = P1^6; //Column3
  39          sbit C4 = P1^7; //Column4
  40          sbit E = P3^6; //E pin for LCD
  41          sbit RS = P3^7; //RS pin for LCD
  42          unsigned int key_count = 0, result_int;
  43          char array[3], result_char;
  44          // ***********************************************************
  45          // Main program
  46          //
  47          int main(void)
  48          {
  49   1       char key; // key char for keeping record of pressed key
  50   1       cct_init(); // Make input and output pins as required
  51   1       lcdinit(); // Initilize LCD
  52   1       
  53   1       while(1)
  54   1       { 
C51 COMPILER V9.60.0.0   TASK02                                                            08/02/2022 17:06:53 PAGE 2   

  55   2       key = get_key(); // Get pressed key
  56   2      if (key == 'C')
  57   2      {
  58   3      writecmd(0x01); // Clear screen
  59   3      array[0]= array[1]= array[2]='n';
  60   3      result_int = 0; key_count = 0;
  61   3      }
  62   2      else if(key == '=')
  63   2      {
  64   3      writedata(key); // Echo the key pressed to LCD
  65   3      if(array[1] == 'x')
  66   3      result_int = (array[0] -'0') * (array[2] - '0');
  67   3      else if(array[1] == '/')
  68   3      result_int = (array[0] -'0') / (array[2] - '0');
  69   3      else if(array[1] == '+')
  70   3      result_int = (array[0] -'0') + (array[2] - '0');
  71   3      else if(array[1] == '-')
  72   3      result_int = (array[0] -'0') - (array[2] - '0');
  73   3      if(result_int > 9) //if the result is greater than 9 then we need to store each digit in an array
  74   3      {
  75   4       int result[2]; //Delare an array
  76   4       result[0] = result_int/10; //Store the digit at ten's place at index 0
  77   4       result[1] = result_int%10; //Store the digit at unit's place at index 1
  78   4       result_char = (char)result[0] + '0';//Convert the integer at index 0 to character
  79   4       writedata(result_char ); // Echo the key pressed to LCD
  80   4       result_char = (char)result[1] + '0';//Convert the integer at index 1 to character
  81   4       writedata(result_char ); // Echo the key pressed to LCD
  82   4      }
  83   3      else
  84   3      {
  85   4       result_char = (char)result_int + '0';
  86   4       writedata(result_char ); // Echo the key pressed to LCD
  87   4      }
  88   3      }
  89   2      else 
  90   2      writedata(key); // Echo the key pressed to LCD
  91   2       }
  92   1      }
  93          void cct_init(void)
  94          {
  95   1              P0 = 0x00; //not used
  96   1              P1 = 0xf0; //used for generating outputs and taking inputs from Keypad
  97   1              P2 = 0x00; //used as data port for LCD
  98   1              P3 = 0x00; //used for RS and E 
  99   1      }
 100          void delay(int a)
 101          {
 102   1               int i;
 103   1               for(i=0;i<a;i++); //null statement
 104   1      }
 105          void writedata(char t)
 106          {
 107   1               RS = 1; // This is data
 108   1               P2 = t; //Data transfer
 109   1               E = 1; // => E = 1
 110   1               delay(150);
 111   1               E = 0; // => E = 0
 112   1               delay(150);
 113   1      }
 114          void writecmd(int z)
 115          {
 116   1               RS = 0; // This is command
C51 COMPILER V9.60.0.0   TASK02                                                            08/02/2022 17:06:53 PAGE 3   

 117   1               P2 = z; //Data transfer
 118   1               E = 1; // => E = 1
 119   1               delay(150);
 120   1               E = 0; // => E = 0
 121   1               delay(150);
 122   1      }
 123          void lcdinit(void)
 124          {
 125   1               ///////////// Reset process from datasheet /////////
 126   1               delay(15000);
 127   1               writecmd(0x30);
 128   1               delay(4500);
 129   1               writecmd(0x30);
 130   1               delay(300);
 131   1               writecmd(0x30);
 132   1               delay(650);
 133   1               /////////////////////////////////////////////////////
 134   1               writecmd(0x38); //function set
 135   1               writecmd(0x0c); //display on,cursor off,blink off
 136   1               writecmd(0x01); //clear display
 137   1               writecmd(0x06); //entry mode, set increment
 138   1      }
 139          void Return(void) //Return to 0 location on LCD
 140          {
 141   1               writecmd(0x02);
 142   1               delay(1500);
 143   1      }
 144          char READ_SWITCHES(void)
 145          {
 146   1              RowA = 0; RowB = 1; RowC = 1; RowD = 1; //Test Row A
 147   1              if (C1 == 0) { delay(10000); while (C1==0); return '7'; }
 148   1              if (C2 == 0){ delay(10000); while (C2==0); return '8'; }
 149   1              if (C3 == 0) { delay(10000); while (C3==0); return '9'; }
 150   1              if (C4 == 0) { delay(10000); while (C4==0); return '/'; }
 151   1              RowA = 1; RowB = 0; RowC = 1; RowD = 1; //Test Row B
 152   1              if (C1 == 0) { delay(10000); while (C1==0); return '4'; }
 153   1              if (C2 == 0) { delay(10000); while (C2==0); return '5'; }
 154   1              if (C3 == 0) { delay(10000); while (C3==0); return '6'; }
 155   1              if (C4 == 0) { delay(10000); while (C4==0); return 'x'; }
 156   1              RowA = 1; RowB = 1; RowC = 0; RowD = 1; //Test Row C
 157   1              if (C1 == 0) { delay(10000); while (C1==0); return '1'; }
 158   1              if (C2 == 0) { delay(10000); while (C2==0); return '2'; }
 159   1              if (C3 == 0) { delay(10000); while (C3==0); return '3'; }
 160   1              if (C4 == 0) { delay(10000); while (C4==0); return '-'; }
 161   1              RowA = 1; RowB = 1; RowC = 1; RowD = 0; //Test Row D
 162   1              if (C1 == 0) { delay(10000); while (C1==0); return 'C'; }
 163   1              if (C2 == 0) { delay(10000); while (C2==0); return '0'; }
 164   1              if (C3 == 0) { delay(10000); while (C3==0); return '='; }
 165   1              if (C4 == 0) { delay(10000); while (C4==0); return '+'; }
 166   1              return 'n'; // Means no key has been pressed
 167   1      }
 168          char get_key(void) //get key from user
 169          {
 170   1              char key = 'n'; //assume no key pressed
 171   1              while(key=='n') //wait untill a key is pressed
 172   1              key = READ_SWITCHES(); //scan the keys again and again
 173   1              array[key_count++]= key;
 174   1              return key; //when key pressed then return its value
 175   1      }
 176              
 177           

C51 COMPILER V9.60.0.0   TASK02                                                            08/02/2022 17:06:53 PAGE 4   


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    714    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      8       5
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
